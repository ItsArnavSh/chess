"use strict";
let turn=1;
let gamer;
let gamePlay;
let prev,prevMove;
document.addEventListener("DOMContentLoaded",()=>{
    //This function is called when the DOM is loaded
    makeBoxes();
    [gamer,gamePlay]=setPieces();
    display(gamer);
    let keys = document.querySelectorAll(".box");
    for(let i = 0;i<keys.length;i++)
    {
        keys[i].onclick = ({target})=>{clicked(target);}
    }
});
//To work with bits, we will assume the chessboard to go from 1 to 64 instead of a8 to h1.
/*
For Reference
01 02 03 04 05 06 07 08
09 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64
*/
////////////////////////////////////////

function numberToMap(n) {
    //This function will take a number, and return 1, shifted by that number. 
    //eg 3 returns 100
    if (typeof n === 'number') {
        n=n-1;
        return(1n<<BigInt(n));
    } else if (Array.isArray(n)) {
        let k = 0n;
        for(let i=0;i<n.length;i++)
        {
            n[i]--;
            k=k|(1n<<BigInt(n[i]));
        }
        return k;
    } else {
        throw new Error('Invalid argument type, expected letter or array');
    }
}
function setPieces()//This will initialize all the pieces
{
    let gamer=[];
    /*
    0-5 Black's pieces
    0-king
    1-queen
    2-rooks
    3-knights
    4-bishops
    5-pawns
    6-11 White's pieces
    */
    // Black pieces
    gamer.push(numberToMap(5)); // Black king
    gamer.push(numberToMap(4)); // Black queen
    gamer.push(numberToMap([1, 8])); // Black rooks
    gamer.push(numberToMap([2, 7])); // Black knights
    gamer.push(numberToMap([3, 6])); // Black bishops
    gamer.push(numberToMap([9, 10, 11, 12, 13, 14, 15, 16])); // Black pawns

    // White pieces
    gamer.push(numberToMap(61)); // White king
    gamer.push(numberToMap(34)); // White queen
    gamer.push(numberToMap([37, 64])); // White rooks
    gamer.push(numberToMap([58, 63])); // White knights
    gamer.push(numberToMap([36, 62])); // White bishops
    gamer.push(numberToMap([49, 50, 51, 52, 53, 54, 55, 56])); // White pawns
    /*
      0 and 1 all black and white pieces
      2- GameState TKQkqE T turn, KQkq means castle in FEN terms and E means en passant avaibility
      3- Available En passant square, if not available, it is 0
    */
    let gamer2=[];
    gamer2.push(numberToMap([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])); // All black pieces
    gamer2.push(numberToMap([49, 50, 51, 52, 53, 54, 55, 56, 37, 58, 36, 34, 61, 62, 63, 64])); // All white pieces
    //For gamestate
    gamer2.push(numberToMap([1,2,3,4,5]));
    gamer2.push(numberToMap(0));//No enpassant sqares at the start of the game
    return [gamer,gamer2];
}
function mapToNumber(bitmap)
{
    //We are given a map and we should return an array of coordinates
    let coordinate=[];
    for(let i=1;i<=64;i++)
    {
        if((bitmap&1n)==1n)
                coordinate.push(i);
            bitmap=bitmap>>1n;
    }
    return coordinate;
}
function mapToString(bitmap)
{
    if(bitmap==null)
        return [];
    //It takes the bitmap of the board, and returns an array of coordinates with the elements which had a 1
    let coordinate = [];
    for(let i=8;i>=1;i--)
    {
        for(let j='a'.charCodeAt(0);j<='h'.charCodeAt(0);j++)
        {
            let id = (`${String.fromCharCode(j)}${i}`);
            if((bitmap&1n)==1n)
                coordinate.push(id);
            bitmap=bitmap>>1n;
        }
    }
    return coordinate;
}
function coordToNum(coord)
{
    //We will make a formula to convert the string to the numerical notation and then the bit
    let x = charToNumber(coord[0]);
    let y = 9-numcharToNumber(coord[1]);
    return(x+8*(y-1));
}
function charToNumber(c) {
    return c.charCodeAt(0) - 'a'.charCodeAt(0)+1;
}
function numcharToNumber(c) {
    return c.charCodeAt(0) - '0'.charCodeAt(0);
}
function makeBoxes()
    {
        let gamer = {};
        const board = document.getElementById("board");
    for(let i=8;i>=1;i--)
    {
        for(let j='a'.charCodeAt(0);j<='h'.charCodeAt(0);j++)
        {
            const box = document.createElement("button");
            box.classList.add("box");
            box.id = (`${String.fromCharCode(j)}${i}`);
            if((i+j)%2==0)
                box.classList.add("odd");
            else
                box.classList.add("even");
            gamer[`${String.fromCharCode(j)}${i}`] = null;
            board.appendChild(box);
        }
    }
};
function display(gamer) {
    // The display will refresh every single move
    let coord;
    let keys;
    
    const pieceNames = ["king-b", "queen-b", "rook-b", "knight-b", "bishop-b", "pawn-b", "king-w", "queen-w", "rook-w", "knight-w", "bishop-w", "pawn-w"];
    const pieceCounts = [1, 1, 2, 2, 2, 8, 1, 1, 2, 2, 2, 8];

    for (let i = 0; i < pieceNames.length; i++) {
        let coords = mapToString(gamer[i]);
        for (let j = 0; j < pieceCounts[i]; j++) {
            coord = coords[j];
            keys = document.getElementById(coord);
            if(keys!=null)
            {
                keys.innerHTML = ''; // Clear the board
                const img = document.createElement("img");
                img.src = `pieces/${pieceNames[i]}.svg`;
                img.height = 43;
                img.style.backgroundColor = 'transparent';
                img.style.pointerEvents = 'none';
                keys.appendChild(img);
            }
        }
    }
}
function clicked(target)
{
    clear();
    const key = target.getAttribute("id");
    const clickedBitMap = numberToMap(coordToNum(key));
    if((clickedBitMap&gamePlay[turn]))
    {
        let moves = (mapToString(whichPieceIsInvoked(clickedBitMap)));
        for(let j=0;j<moves.length;j++)
        {
            let change = document.getElementById(moves[j]);
            if(numberToMap(coordToNum(moves[j]))&gamePlay[turn == 1n ? 0 : 1])
            {
                change.style.border = '2px solid red';
                change.classList.add("red");
            }
            else
            {
            let indicator = document.createElement("img");
            indicator.src = "pieces/blackDot.png";
            indicator.height=20;
            indicator.classList.add("temp");
            indicator.style.backgroundColor = 'transparent';
            indicator.style.pointerEvents = 'none';
            if((moves[j].charCodeAt(0)+parseInt(moves[j][1],10))%2==0)
            {
                indicator.style.filter = 'brightness(500%)';
                indicator.style.opacity = '0.2';
            }
            //piece.charCodeAt(0)+x)}${parseInt(piece[1],10)+y
            indicator.style.opacity = '0.2';
            change.appendChild(indicator);
            }
        }
        prevMove = clickedBitMap;
        prev = (whichPieceIsInvoked(clickedBitMap));
    }
    else if(prev!=undefined && (clickedBitMap & prev))
    {
        for(let i=0;i<12;i++)
        {
            if(gamer[i]&prevMove)
            {
                gamer[i] = gamer[i]&();
                gamePlay[turn] ^=prevMove;
                console.log(mapToString(gamer[i]));
                break;
            }
        }
        display(gamer);
    }
    else
        console.log("Empty Space");

}
function whichPieceIsInvoked(bitboard)
{
    //Accepts the bitboard of clicked piece and returns the bitboard with all attacks available
    //First we need to figure out which piece is it
    let range = turn==1?6:0;
    for(let i = range; i < range + 6; i++) {
        if(gamer[i] & bitboard) {
            switch(i % 6) {
                case 0: return king(bitboard);
                case 1: return queen(bitboard);
                case 2: return rook(bitboard);
                case 3: return knight(bitboard);
                case 4: return bishop(bitboard);
                case 5: return pawn(bitboard);
            }
        }
    }
}
function king(bitboard)
{

}
function queen(bitboard)
{
    return(rook(bitboard)|bishop(bitboard));
}
function rook(bitboard) {
    let attacks = 0n;
    let n = mapToNumber(bitboard)[0];
    //Up
    for(let i= 1; i <= n; i++) {
        let check = shift(bitboard, 0, -i);
        if(check & gamePlay[turn]) {
            break;
        }
        else if(check & gamePlay[turn == 1n ? 0 : 1]) {
            attacks |= check;
            break;
        }
        else {
            attacks |= check;
        }
    }
    // Down
    for(let i= 1; i <= 64 - n; i++) {
    let check = shift(bitboard, 0, i);
    if(check & gamePlay[turn]) {
        break;
    }
    else if(check & gamePlay[turn == 1n ? 0 : 1]) {
        attacks |= check;
        break;
    }
    else {
        attacks |= check;
    }
}
    // Left
for(let i= 1; i <= n % 8; i++) {
    let check = shift(bitboard, -i, 0);
    console.log(mapToNumber(check)[0]);
    if(check & gamePlay[turn]) {
        break;
    }
    else if(check & gamePlay[turn == 1n ? 0 : 1]) {
        attacks |= check;
        break;
    }
    else {
        attacks |= check;
    }
    if((mapToNumber(bitboard)[0]-1)%8==0)
        break;
}

// Right
for(let i= 1; i <= 8 - n % 8; i++) {
    let check = shift(bitboard, i, 0);
    if(check & gamePlay[turn]) {
        break;
    }
    else if(check & gamePlay[turn == 1n ? 0 : 1]) {
        attacks |= check;
        break;
    }
    else {
        attacks |= check;
    }
}
    return attacks;
}
function knight(bitboard) {
    let attacks = 0n;
    let n = mapToNumber(bitboard)[0];

    // Define all possible knight moves
    let moves = [
        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
        [1, -2], [1, 2], [2, -1], [2, 1]
    ];
    for(let move of moves) {
        let check = shift(bitboard, move[0], move[1]);
        if(!(check & gamePlay[turn])) {
                attacks |= check;
        }
    }

    return attacks;
}
function bishop(bitboard) {
    let attacks = 0n;
    let n = mapToNumber(bitboard)[0];

    // Up-Left
    for(let i= 1; i <= Math.min(n % 8, Math.floor(n / 8)); i++) {
        let check = shift(bitboard, -i, -i);
        if(check & gamePlay[turn]) {
            break;
        }
        else if(check & gamePlay[turn == 1n ? 0 : 1]) {
            attacks |= check;
            break;
        }
        else {
            attacks |= check;
        }
    }

    // Up-Right
    for(let i= 1; i <= Math.min(8 - n % 8, Math.floor(n / 8)); i++) {
        let check = shift(bitboard, i, -i);
        if(check & gamePlay[turn]) {
            break;
        }
        else if(check & gamePlay[turn == 1n ? 0 : 1]) {
            attacks |= check;
            break;
        }
        else {
            attacks |= check;
        }
    }

    // Down-Left
    for(let i= 1; i <= Math.min(n % 8, 64 - n / 8); i++) {
        let check = shift(bitboard, -i, i);
        if(check & gamePlay[turn]) {
            break;
        }
        else if(check & gamePlay[turn == 1n ? 0 : 1]) {
            attacks |= check;
            break;
        }
        else {
            attacks |= check;
        }
    }

    // Down-Right
    for(let i= 1; i <= Math.min(8 - n % 8, 64 - n / 8); i++) {
        let check = shift(bitboard, i, i);
        if(check & gamePlay[turn]) {
            break;
        }
        else if(check & gamePlay[turn == 1n ? 0 : 1]) {
            attacks |= check;
            break;
        }
        else {
            attacks |= check;
        }
    }

    return attacks;
}
function pawn(bitboard)
{
    let direction = turn?-1:1;
    return shift(bitboard,0,direction);
}
function shift(bitboard,x,y)
{
    //This function will return your shifted bitboard by specified x and y
    let shiftval = x+8*(y);
    return(bitboard<<BigInt(shiftval));
}
function distanceBetweenStrings(a, b) {
    console.log(a,b);
    // Convert the chess coordinates to 0-based indices
    let x1 = a.charCodeAt(0) - 'a'.charCodeAt(0);
    let y1 = parseInt(a[1]) - 1;
    let x2 = b.charCodeAt(0) - 'a'.charCodeAt(0);
    let y2 = parseInt(b[1]) - 1;

    // Calculate the distances in the x and y axes
    let dx = Math.abs(x2 - x1);
    let dy = Math.abs(y2 - y1);

    // Return the larger distance
    return Math.max(dx, dy);
}
function clear() {
    let elements = document.getElementsByClassName('temp');
    while(elements.length > 0){
        elements[0].parentNode.removeChild(elements[0]);
    }
    elements = document.getElementsByClassName('red');
    for(let l = 0;l<elements.length;l++)
    {
        elements[l].style.border = "1px solid black";
    }
}